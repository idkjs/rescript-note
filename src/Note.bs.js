// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var $$Set = require("rescript/lib/js/set.js");
var Caml = require("rescript/lib/js/caml.js");
var List = require("rescript/lib/js/list.js");
var Curry = require("rescript/lib/js/curry.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Caml_module = require("rescript/lib/js/caml_module.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

var Src = Caml_module.init_mod([
      "Note.res",
      18,
      4
    ], {
      TAG: /* Module */0,
      _0: [
        [
          /* Function */0,
          "compare"
        ],
        [
          /* Function */0,
          "id"
        ],
        [
          /* Function */0,
          "cell"
        ],
        [
          /* Function */0,
          "untyped"
        ],
        [
          /* Function */0,
          "logrs"
        ],
        [
          /* Function */0,
          "add_logr"
        ],
        [
          /* Function */0,
          "rem_logr"
        ],
        [
          /* Function */0,
          "reset_stamp"
        ],
        [
          /* Function */0,
          "find_active_step"
        ],
        [
          /* Function */0,
          "create"
        ]
      ]
    });

var C = Caml_module.init_mod([
      "Note.res",
      124,
      4
    ], {
      TAG: /* Module */0,
      _0: [
        [
          /* Function */0,
          "create"
        ],
        [
          /* Function */0,
          "const"
        ],
        [
          /* Function */0,
          "eq"
        ],
        [
          /* Function */0,
          "set_eq"
        ],
        [
          /* Function */0,
          "with_eq"
        ],
        [
          /* Function */0,
          "stamp"
        ],
        [
          /* Function */0,
          "set_stamp"
        ],
        [
          /* Function */0,
          "srcs"
        ],
        [
          /* Function */0,
          "srcs_changed"
        ],
        [
          /* Function */0,
          "set_srcs"
        ],
        [
          /* Function */0,
          "set_srcs_changed"
        ],
        [
          /* Function */0,
          "value"
        ],
        [
          /* Function */0,
          "value_changed"
        ],
        [
          /* Function */0,
          "set_value"
        ],
        [
          /* Function */0,
          "update"
        ],
        [
          /* Function */0,
          "set_update"
        ],
        [
          /* Function */0,
          "src_update"
        ],
        [
          /* Function */0,
          "up_to_date_value"
        ],
        [
          /* Function */0,
          "create_instant"
        ],
        [
          /* Function */0,
          "set_instant"
        ],
        [
          /* Function */0,
          "delay"
        ],
        [
          /* Function */0,
          "fix"
        ],
        [
          /* Function */0,
          "defer"
        ],
        [
          /* Function */0,
          "dump_src_ids"
        ]
      ]
    });

var Logr = Caml_module.init_mod([
      "Note.res",
      320,
      4
    ], {
      TAG: /* Module */0,
      _0: [
        [
          /* Function */0,
          "const"
        ],
        [
          /* Function */0,
          "obs_cell"
        ],
        [
          /* Function */0,
          "app"
        ],
        [
          /* Function */0,
          "dollar"
        ],
        [
          /* Function */0,
          "create"
        ],
        [
          /* Function */0,
          "for_cell"
        ],
        [
          /* Function */0,
          "force"
        ],
        [
          /* Function */0,
          "destroy"
        ],
        [
          /* Function */0,
          "update"
        ],
        [
          /* Function */0,
          "hold"
        ],
        [
          /* Function */0,
          "may_hold"
        ],
        [
          /* Function */0,
          "unhold_all"
        ]
      ]
    });

var Srcs = $$Set.Make(Src);

function create(param) {
  return {
          srcs: Srcs.empty,
          delayed: Srcs.empty,
          cleanup: /* [] */0
        };
}

var nil = {
  srcs: Srcs.empty,
  delayed: Srcs.empty,
  cleanup: /* [] */0
};

var delayed = {
  srcs: Srcs.empty,
  delayed: Srcs.empty,
  cleanup: /* [] */0
};

function add_src(step, src) {
  step.srcs = Curry._2(Srcs.add, src, step.srcs);
  
}

function add_delayed(step, src) {
  step.delayed = Curry._2(Srcs.add, src, step.delayed);
  
}

function add_cleanup(step, clean) {
  step.cleanup = {
    hd: clean,
    tl: step.cleanup
  };
  
}

function cleanup(step) {
  List.iter((function (f) {
          return Curry._1(f, undefined);
        }), step.cleanup);
  step.cleanup = /* [] */0;
  
}

function already_executed(param) {
  return Pervasives.invalid_arg("step already executed");
}

function execute_delayed(srcs) {
  var ds = {
    srcs: srcs,
    delayed: Srcs.empty,
    cleanup: /* [] */0
  };
  delayed.srcs = srcs;
  Curry._2(Srcs.iter, (function (param) {
          var c = Curry._1(Src.cell, param._0);
          Curry._2(C.update, delayed, c);
          return Curry._2(C.set_stamp, c, ds);
        }), srcs);
  return execute(ds);
}

function execute(step) {
  var update_src_logs = function (src) {
    return List.iter(Curry._1(Logr.update, step), Curry._1(Src.logrs, src));
  };
  Curry._2(Srcs.iter, update_src_logs, step.srcs);
  Curry._2(Srcs.iter, Src.reset_stamp, step.srcs);
  cleanup(step);
  add_cleanup(step, already_executed);
  if (Curry._1(Srcs.is_empty, step.delayed)) {
    return ;
  } else {
    return execute_delayed(step.delayed);
  }
}

function id(s) {
  return s._0.id;
}

function cell(s) {
  return s.cell;
}

function untyped(s) {
  return s.self;
}

function compare(s, t) {
  return Caml.caml_int_compare(s._0.id, t._0.id);
}

function logrs(s) {
  return s._0.logrs;
}

function add_logr(logr, s) {
  var s$1 = s._0;
  s$1.logrs = {
    hd: logr,
    tl: s$1.logrs
  };
  
}

function rem_logr(logr, s) {
  var s$1 = s._0;
  var rem = function (logr, _acc, _x) {
    while(true) {
      var x = _x;
      var acc = _acc;
      if (!x) {
        return acc;
      }
      var vs = x.tl;
      var v = x.hd;
      if (v === logr) {
        return List.rev_append(vs, acc);
      }
      _x = vs;
      _acc = {
        hd: v,
        tl: acc
      };
      continue ;
    };
  };
  s$1.logrs = rem(logr, /* [] */0, s$1.logrs);
  
}

function reset_stamp(s) {
  return Curry._2(C.set_stamp, s._0.cell, nil);
}

var Step = /* @__PURE__ */Caml_exceptions.create("Note.Src.Step");

function find_active_step(step, ss) {
  if (step !== nil) {
    return step;
  }
  var find_not_nil = function (s) {
    var step = Curry._1(C.stamp, s._0.cell);
    if (step === nil) {
      return ;
    }
    throw {
          RE_EXN_ID: Step,
          _1: step,
          Error: new Error()
        };
  };
  try {
    Curry._2(Srcs.iter, find_not_nil, ss);
    return nil;
  }
  catch (raw_s){
    var s = Caml_js_exceptions.internalToOCamlException(raw_s);
    if (s.RE_EXN_ID === Step) {
      return s._1;
    }
    throw s;
  }
}

var id$1 = {
  contents: 0
};

function create$1(eq, v) {
  var update = function (param, param$1) {
    
  };
  var cell = Curry._5(C.create, eq, nil, Srcs.empty, v, update);
  var src = {};
  Caml_obj.update_dummy(src, {
        id: (id$1.contents = id$1.contents + 1 | 0, id$1.contents),
        cell: cell,
        logrs: /* [] */0,
        self: /* V */{
          _0: src
        }
      });
  Curry._2(C.set_srcs, cell, Curry._1(Srcs.singleton, src.self));
  Curry._2(C.set_srcs_changed, cell, false);
  return src;
}

Caml_module.update_mod({
      TAG: /* Module */0,
      _0: [
        [
          /* Function */0,
          "compare"
        ],
        [
          /* Function */0,
          "id"
        ],
        [
          /* Function */0,
          "cell"
        ],
        [
          /* Function */0,
          "untyped"
        ],
        [
          /* Function */0,
          "logrs"
        ],
        [
          /* Function */0,
          "add_logr"
        ],
        [
          /* Function */0,
          "rem_logr"
        ],
        [
          /* Function */0,
          "reset_stamp"
        ],
        [
          /* Function */0,
          "find_active_step"
        ],
        [
          /* Function */0,
          "create"
        ]
      ]
    }, Src, {
      compare: compare,
      id: id,
      cell: cell,
      untyped: untyped,
      logrs: logrs,
      add_logr: add_logr,
      rem_logr: rem_logr,
      reset_stamp: reset_stamp,
      find_active_step: find_active_step,
      create: create$1
    });

function create$2(eqOpt, step, srcs, value, update) {
  var eq = eqOpt !== undefined ? eqOpt : Caml_obj.caml_equal;
  return {
          eq: eq,
          stamp: step,
          srcs: srcs,
          srcs_changed: true,
          value: value,
          value_changed: true,
          update: update
        };
}

function $$const(eqOpt, v) {
  var eq = eqOpt !== undefined ? eqOpt : Caml_obj.caml_equal;
  return {
          eq: eq,
          stamp: nil,
          srcs: Srcs.empty,
          srcs_changed: false,
          value: v,
          value_changed: false,
          update: (function (param, param$1) {
              
            })
        };
}

function eq(c) {
  return c.eq;
}

function set_eq(c, eq) {
  c.eq = eq;
  
}

function with_eq(eq, c) {
  return {
          eq: eq,
          stamp: c.stamp,
          srcs: c.srcs,
          srcs_changed: c.srcs_changed,
          value: c.value,
          value_changed: c.value_changed,
          update: c.update
        };
}

function stamp(c) {
  return c.stamp;
}

function set_stamp(c, stamp) {
  c.stamp = stamp;
  
}

function srcs_changed(c) {
  return c.srcs_changed;
}

function set_srcs_changed(c, bool) {
  c.srcs_changed = bool;
  
}

function srcs(c) {
  return c.srcs;
}

function set_srcs(c, srcs) {
  c.srcs_changed = true;
  c.srcs = srcs;
  
}

function value(c) {
  return c.value;
}

function value_changed(c) {
  return c.value_changed;
}

function set_value(c, v) {
  if (Curry._2(c.eq, v, c.value)) {
    return ;
  } else {
    c.value_changed = true;
    c.value = v;
    return ;
  }
}

function update(step, c) {
  if (step !== nil && c.stamp !== step) {
    c.stamp = step;
    c.srcs_changed = false;
    c.value_changed = false;
    if (Curry._1(Srcs.is_empty, Curry._2(Srcs.inter, c.srcs, step.srcs))) {
      return ;
    } else {
      return Curry._2(c.update, step, c);
    }
  }
  
}

function set_update(c, u) {
  c.update = u;
  
}

function src_update(step, c, v) {
  c.value_changed = false;
  if (Curry._2(c.eq, v, c.value)) {
    return false;
  } else {
    c.stamp = step;
    c.value_changed = true;
    c.value = v;
    return true;
  }
}

function up_to_date_value(c) {
  var step = Curry._2(Src.find_active_step, nil, c.srcs);
  update(step, c);
  return c.value;
}

function reset_instant(c) {
  c.value_changed = false;
  c.value = undefined;
  
}

function set_instant(step, c, x) {
  if (x !== undefined) {
    c.value_changed = true;
    c.value = x;
    return add_cleanup(step, (function (param) {
                  return reset_instant(c);
                }));
  }
  
}

function create_instant(step, srcs, value, update) {
  var value_changed = value !== undefined;
  var c = {
    eq: Caml_obj.caml_equal,
    stamp: step,
    srcs: srcs,
    srcs_changed: true,
    value: value,
    value_changed: value_changed,
    update: update
  };
  if (value_changed && Caml_obj.caml_notequal(step, nil)) {
    add_cleanup(step, (function (param) {
            return reset_instant(c);
          }));
  }
  return c;
}

function delay(i, z) {
  return Pervasives.failwith("TOOD");
}

function fix(eq, i, cf) {
  var src = Curry._2(Src.create, eq, i);
  var src$1 = /* V */{
    _0: src
  };
  var d = Curry._1(Src.cell, src);
  var match = Curry._1(cf, d);
  var c = match[0];
  var c_update = c.update;
  var c_update$1 = function (step, self) {
    Curry._2(c_update, step, self);
    if (c.value_changed) {
      return add_delayed(step, src$1);
    }
    
  };
  var d_update = function (step, self) {
    if (step === delayed) {
      return set_value(self, c.value);
    }
    
  };
  c.update = c_update$1;
  d.update = d_update;
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, c));
  update(step, c);
  if (step === nil) {
    execute_delayed(Curry._1(Srcs.singleton, src$1));
  }
  return match[1];
}

function defer(init, c) {
  var src = Curry._2(Src.create, c.eq, init);
  var src$1 = /* V */{
    _0: src
  };
  var d = Curry._1(Src.cell, src);
  var update = function (step, self) {
    if (step === delayed) {
      return set_value(self, c.value);
    } else {
      Curry._2(C.update, step, c);
      if (Curry._1(C.srcs_changed, c)) {
        Curry._2(C.set_srcs, d, Curry._1(C.srcs, c));
      }
      if (Curry._1(C.value_changed, c)) {
        return add_delayed(step, src$1);
      } else {
        return ;
      }
    }
  };
  d.update = update;
  var step = Curry._2(Src.find_active_step, nil, c.srcs);
  update(step, c);
  update(step, d);
  if (step === nil) {
    execute_delayed(Curry._1(Srcs.singleton, src$1));
  }
  return d;
}

function dump_src_ids(ppf, c) {
  console.log(ppf, "@[{%a}@]", List.map((function (s) {
              return Curry._1(Src.id, s);
            }), Curry._1(Srcs.elements, c.srcs)));
  
}

Caml_module.update_mod({
      TAG: /* Module */0,
      _0: [
        [
          /* Function */0,
          "create"
        ],
        [
          /* Function */0,
          "const"
        ],
        [
          /* Function */0,
          "eq"
        ],
        [
          /* Function */0,
          "set_eq"
        ],
        [
          /* Function */0,
          "with_eq"
        ],
        [
          /* Function */0,
          "stamp"
        ],
        [
          /* Function */0,
          "set_stamp"
        ],
        [
          /* Function */0,
          "srcs"
        ],
        [
          /* Function */0,
          "srcs_changed"
        ],
        [
          /* Function */0,
          "set_srcs"
        ],
        [
          /* Function */0,
          "set_srcs_changed"
        ],
        [
          /* Function */0,
          "value"
        ],
        [
          /* Function */0,
          "value_changed"
        ],
        [
          /* Function */0,
          "set_value"
        ],
        [
          /* Function */0,
          "update"
        ],
        [
          /* Function */0,
          "set_update"
        ],
        [
          /* Function */0,
          "src_update"
        ],
        [
          /* Function */0,
          "up_to_date_value"
        ],
        [
          /* Function */0,
          "create_instant"
        ],
        [
          /* Function */0,
          "set_instant"
        ],
        [
          /* Function */0,
          "delay"
        ],
        [
          /* Function */0,
          "fix"
        ],
        [
          /* Function */0,
          "defer"
        ],
        [
          /* Function */0,
          "dump_src_ids"
        ]
      ]
    }, C, {
      create: create$2,
      $$const: $$const,
      eq: eq,
      set_eq: set_eq,
      with_eq: with_eq,
      stamp: stamp,
      set_stamp: set_stamp,
      srcs: srcs,
      srcs_changed: srcs_changed,
      set_srcs: set_srcs,
      set_srcs_changed: set_srcs_changed,
      value: value,
      value_changed: value_changed,
      set_value: set_value,
      update: update,
      set_update: set_update,
      src_update: src_update,
      up_to_date_value: up_to_date_value,
      create_instant: create_instant,
      set_instant: set_instant,
      delay: delay,
      fix: fix,
      defer: defer,
      dump_src_ids: dump_src_ids
    });

function $$const$1(v) {
  return [
          /* [] */0,
          (function (param) {
              return v;
            })
        ];
}

function obs_cell(c) {
  return [
          {
            hd: /* C */{
              _0: c
            },
            tl: /* [] */0
          },
          (function (param) {
              return Curry._1(C.value, c);
            })
        ];
}

function app(param, param$1) {
  var v = param$1[1];
  var f = param[1];
  return [
          List.rev_append(param[0], param$1[0]),
          (function (param) {
              return Curry._2(f, undefined, Curry._1(v, undefined));
            })
        ];
}

function update_srcs(l) {
  var cells_srcs = function (l) {
    var add_cell = function (acc, c) {
      return Curry._2(Srcs.union, acc, Curry._1(C.srcs, c._0));
    };
    return List.fold_left(add_cell, Srcs.empty, l.cells);
  };
  var new_srcs = cells_srcs(l);
  var rems = Curry._2(Srcs.diff, l.srcs, new_srcs);
  var adds = Curry._2(Srcs.diff, new_srcs, l.srcs);
  Curry._2(Srcs.iter, Curry._1(Src.rem_logr, l), rems);
  Curry._2(Srcs.iter, Curry._1(Src.add_logr, l), adds);
  l.srcs = new_srcs;
  
}

function update$1(step, l) {
  if (!(step !== nil && step !== l.stamp)) {
    return ;
  }
  l.stamp = step;
  var _srcs_changed = false;
  var _value_changed = false;
  var _x = l.cells;
  while(true) {
    var x = _x;
    var value_changed = _value_changed;
    var srcs_changed = _srcs_changed;
    if (x) {
      var c = x.hd._0;
      Curry._2(C.update, step, c);
      _x = x.tl;
      _value_changed = value_changed || Curry._1(C.value_changed, c);
      _srcs_changed = srcs_changed || Curry._1(C.srcs_changed, c);
      continue ;
    }
    if (srcs_changed) {
      update_srcs(l);
    }
    if (value_changed) {
      return Curry._1(l.log, undefined);
    } else {
      return ;
    }
  };
}

function force(l) {
  var step = Curry._2(Src.find_active_step, nil, l.srcs);
  update$1(step, l);
  return Curry._1(l.log, undefined);
}

function create$3($staropt$star, param) {
  var now = $staropt$star !== undefined ? $staropt$star : true;
  var l = {
    stamp: nil,
    srcs: Srcs.empty,
    cells: param[0],
    log: param[1]
  };
  update_srcs(l);
  if (now) {
    force(l);
  }
  return l;
}

function for_cell(now, c, log) {
  return create$3(now, [
              {
                hd: /* C */{
                  _0: c
                },
                tl: /* [] */0
              },
              (function (param) {
                  return Curry._1(log, Curry._1(C.value, c));
                })
            ]);
}

function destroy(l) {
  return Curry._2(Srcs.iter, Curry._1(Src.rem_logr, l), l.srcs);
}

var held = {
  contents: /* [] */0
};

function hold(l) {
  held.contents = {
    hd: l,
    tl: held.contents
  };
  
}

function may_hold(x) {
  if (x !== undefined) {
    return hold(Caml_option.valFromOption(x));
  }
  
}

function unhold_all(param) {
  List.iter(destroy, held.contents);
  held.contents = /* [] */0;
  
}

Caml_module.update_mod({
      TAG: /* Module */0,
      _0: [
        [
          /* Function */0,
          "const"
        ],
        [
          /* Function */0,
          "obs_cell"
        ],
        [
          /* Function */0,
          "app"
        ],
        [
          /* Function */0,
          "dollar"
        ],
        [
          /* Function */0,
          "create"
        ],
        [
          /* Function */0,
          "for_cell"
        ],
        [
          /* Function */0,
          "force"
        ],
        [
          /* Function */0,
          "destroy"
        ],
        [
          /* Function */0,
          "update"
        ],
        [
          /* Function */0,
          "hold"
        ],
        [
          /* Function */0,
          "may_hold"
        ],
        [
          /* Function */0,
          "unhold_all"
        ]
      ]
    }, Logr, {
      $$const: $$const$1,
      obs_cell: obs_cell,
      app: app,
      dollar: app,
      create: create$3,
      for_cell: for_cell,
      force: force,
      destroy: destroy,
      update: update$1,
      hold: hold,
      may_hold: may_hold,
      unhold_all: unhold_all
    });

function log(now, e, f) {
  var wrap = function (x) {
    if (x !== undefined) {
      return Curry._1(f, Caml_option.valFromOption(x));
    }
    
  };
  return Caml_option.some(Curry._3(Logr.for_cell, now, e, wrap));
}

function create$4(param) {
  var src = Curry._2(Src.create, undefined, undefined);
  var send = function (step, v) {
    var match = step !== undefined ? [
        Caml_option.valFromOption(step),
        false
      ] : [
        {
          srcs: Srcs.empty,
          delayed: Srcs.empty,
          cleanup: /* [] */0
        },
        true
      ];
    var step$1 = match[0];
    Curry._2(C.set_stamp, Curry._1(Src.cell, src), step$1);
    Curry._3(C.set_instant, step$1, Curry._1(Src.cell, src), Caml_option.some(v));
    add_src(step$1, Curry._1(Src.untyped, src));
    if (match[1]) {
      return execute(step$1);
    }
    
  };
  return [
          Curry._1(Src.cell, src),
          send
        ];
}

var never = Curry._2(C.$$const, undefined, undefined);

function bind(e, f) {
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, e));
  Curry._2(C.update, step, e);
  var curr = Curry._1(C.value, e);
  var current = curr !== undefined ? Curry._1(f, Caml_option.valFromOption(curr)) : never;
  var current$1 = {
    contents: current
  };
  var update = function (step, self) {
    Curry._2(C.update, step, e);
    var curr = Curry._1(C.value, e);
    if (curr !== undefined) {
      current$1.contents = Curry._1(f, Caml_option.valFromOption(curr));
      Curry._2(C.update, step, current$1.contents);
      Curry._2(C.set_srcs, self, Curry._2(Srcs.union, Curry._1(C.srcs, e), Curry._1(C.srcs, current$1.contents)));
      return Curry._3(C.set_instant, step, self, Curry._1(C.value, current$1.contents));
    } else {
      Curry._2(C.update, step, current$1.contents);
      if (Curry._1(C.srcs_changed, e) || Curry._1(C.srcs_changed, current$1.contents)) {
        Curry._2(C.set_srcs, self, Curry._2(Srcs.union, Curry._1(C.srcs, e), Curry._1(C.srcs, current$1.contents)));
      }
      return Curry._3(C.set_instant, step, self, Curry._1(C.value, current$1.contents));
    }
  };
  var step$1 = Curry._2(Src.find_active_step, step, Curry._1(C.srcs, current$1.contents));
  Curry._2(C.update, step$1, current$1.contents);
  var srcs = Curry._2(Srcs.union, Curry._1(C.srcs, e), Curry._1(C.srcs, current$1.contents));
  var init = Curry._1(C.value, current$1.contents);
  return Curry._4(C.create_instant, step$1, srcs, init, update);
}

function join(ee) {
  return bind(ee, (function (e) {
                return e;
              }));
}

function swap(es) {
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, es));
  Curry._2(C.update, step, es);
  var current = {
    contents: Curry._1(C.value, es)
  };
  var update = function (step, self) {
    Curry._2(C.update, step, es);
    if (Curry._1(C.value_changed, es)) {
      current.contents = Curry._1(C.value, es);
      Curry._2(C.update, step, current.contents);
      Curry._2(C.set_srcs, self, Curry._2(Srcs.union, Curry._1(C.srcs, es), Curry._1(C.srcs, current.contents)));
    } else {
      Curry._2(C.update, step, current.contents);
      if (Curry._1(C.srcs_changed, es) || Curry._1(C.srcs_changed, current.contents)) {
        Curry._2(C.set_srcs, self, Curry._2(Srcs.union, Curry._1(C.srcs, es), Curry._1(C.srcs, current.contents)));
      }
      
    }
    return Curry._3(C.set_instant, step, self, Curry._1(C.value, current.contents));
  };
  var step$1 = Curry._2(Src.find_active_step, step, Curry._1(C.srcs, current.contents));
  Curry._2(C.update, step$1, current.contents);
  var srcs = Curry._2(Srcs.union, Curry._1(C.srcs, es), Curry._1(C.srcs, current.contents));
  var init = Curry._1(C.value, current.contents);
  return Curry._4(C.create_instant, step$1, srcs, init, update);
}

function map(f, e) {
  var map$1 = function (f, x) {
    if (x !== undefined) {
      return Caml_option.some(Curry._1(f, Caml_option.valFromOption(x)));
    }
    
  };
  var update = function (step, self) {
    Curry._2(C.update, step, e);
    if (Curry._1(C.srcs_changed, e)) {
      Curry._2(C.set_srcs, self, Curry._1(C.srcs, e));
    }
    return Curry._3(C.set_instant, step, self, map$1(f, Curry._1(C.value, e)));
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, e));
  Curry._2(C.update, step, e);
  return Curry._4(C.create_instant, step, Curry._1(C.srcs, e), map$1(f, Curry._1(C.value, e)), update);
}

function stamp$1(e, v) {
  var stamp$2 = function (x) {
    if (x !== undefined) {
      return Caml_option.some(v);
    }
    
  };
  var update = function (step, self) {
    Curry._2(C.update, step, e);
    if (Curry._1(C.srcs_changed, e)) {
      Curry._2(C.set_srcs, self, Curry._1(C.srcs, e));
    }
    return Curry._3(C.set_instant, step, self, stamp$2(Curry._1(C.value, e)));
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, e));
  Curry._2(C.update, step, e);
  var init = stamp$2(Curry._1(C.value, e));
  return Curry._4(C.create_instant, step, Curry._1(C.srcs, e), init, update);
}

function filter(f, e) {
  var filter$1 = function (f, x) {
    if (x !== undefined && Curry._1(f, Caml_option.valFromOption(x))) {
      return x;
    }
    
  };
  var update = function (step, self) {
    Curry._2(C.update, step, e);
    if (Curry._1(C.srcs_changed, e)) {
      Curry._2(C.set_srcs, self, Curry._1(C.srcs, e));
    }
    return Curry._3(C.set_instant, step, self, filter$1(f, Curry._1(C.value, e)));
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, e));
  Curry._2(C.update, step, e);
  var init = filter$1(f, Curry._1(C.value, e));
  return Curry._4(C.create_instant, step, Curry._1(C.srcs, e), init, update);
}

function filter_map(f, e) {
  var filter_map$1 = function (f, x) {
    if (x !== undefined) {
      return Curry._1(f, Caml_option.valFromOption(x));
    }
    
  };
  var update = function (step, self) {
    Curry._2(C.update, step, e);
    if (Curry._1(C.srcs_changed, e)) {
      Curry._2(C.set_srcs, self, Curry._1(C.srcs, e));
    }
    return Curry._3(C.set_instant, step, self, filter_map$1(f, Curry._1(C.value, e)));
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, e));
  Curry._2(C.update, step, e);
  var init = filter_map$1(f, Curry._1(C.value, e));
  return Curry._4(C.create_instant, step, Curry._1(C.srcs, e), init, update);
}

function select(es) {
  var add_srcs = function (acc, e) {
    return Curry._2(Srcs.union, acc, Curry._1(C.srcs, e));
  };
  var or_srcs_changed = function (acc, e) {
    if (acc) {
      return true;
    } else {
      return Curry._1(C.srcs_changed, e);
    }
  };
  var update = function (step, self) {
    List.iter(Curry._1(C.update, step), es);
    var srcs_changed = List.fold_left(or_srcs_changed, false, es);
    if (srcs_changed) {
      Curry._2(C.set_srcs, self, List.fold_left(add_srcs, Srcs.empty, es));
    }
    var v;
    var exit = 0;
    var e;
    try {
      e = List.find((function (e) {
              return Curry._1(C.value, e) !== undefined;
            }), es);
      exit = 1;
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        v = undefined;
      } else {
        throw exn;
      }
    }
    if (exit === 1) {
      v = Curry._1(C.value, e);
    }
    return Curry._3(C.set_instant, step, self, v);
  };
  var find_step = function (step, e) {
    return Curry._2(Src.find_active_step, step, Curry._1(C.srcs, e));
  };
  var step = List.fold_left(find_step, nil, es);
  List.iter(Curry._1(C.update, step), es);
  var init;
  var exit = 0;
  var e;
  try {
    e = List.find((function (e) {
            return Curry._1(C.value, e) !== undefined;
          }), es);
    exit = 1;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Not_found") {
      init = undefined;
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    init = Curry._1(C.value, e);
  }
  var srcs = List.fold_left(add_srcs, Srcs.empty, es);
  return Curry._4(C.create_instant, step, srcs, init, update);
}

function accum(acc, e) {
  var acc$1 = {
    contents: acc
  };
  var accum$1 = function (x) {
    if (x !== undefined) {
      acc$1.contents = Curry._1(x, acc$1.contents);
      return Caml_option.some(acc$1.contents);
    }
    
  };
  var update = function (step, self) {
    Curry._2(C.update, step, e);
    if (Curry._1(C.srcs_changed, e)) {
      Curry._2(C.set_srcs, self, Curry._1(C.srcs, e));
    }
    return Curry._3(C.set_instant, step, self, accum$1(Curry._1(C.value, e)));
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, e));
  Curry._2(C.update, step, e);
  var init = accum$1(Curry._1(C.value, e));
  return Curry._4(C.create_instant, step, Curry._1(C.srcs, e), init, update);
}

function until(limitOpt, next, e) {
  var limit = limitOpt !== undefined ? limitOpt : false;
  var nop = function (step, self) {
    
  };
  var update = function (step, self) {
    Curry._2(C.update, step, next);
    Curry._2(C.update, step, e);
    var match = Curry._1(C.value, next);
    if (match !== undefined) {
      Curry._2(C.set_srcs, self, Srcs.empty);
      Curry._2(C.set_update, self, nop);
      return Curry._3(C.set_instant, step, self, limit ? Curry._1(C.value, e) : undefined);
    } else {
      if (Curry._1(C.srcs_changed, next) || Curry._1(C.srcs_changed, e)) {
        Curry._2(C.set_srcs, self, Curry._2(Srcs.union, Curry._1(C.srcs, next), Curry._1(C.srcs, e)));
      }
      return Curry._3(C.set_instant, step, self, Curry._1(C.value, e));
    }
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, next));
  var step$1 = Curry._2(Src.find_active_step, step, Curry._1(C.srcs, e));
  Curry._2(C.update, step$1, next);
  Curry._2(C.update, step$1, e);
  var match = Curry._1(C.value, next);
  if (match !== undefined) {
    var init = limit ? Curry._1(C.value, e) : undefined;
    return Curry._4(C.create_instant, step$1, Srcs.empty, init, nop);
  }
  var srcs = Curry._2(Srcs.union, Curry._1(C.srcs, next), Curry._1(C.srcs, e));
  return Curry._4(C.create_instant, step$1, srcs, Curry._1(C.value, e), update);
}

function follow(e, on) {
  var deps_srcs = function (e, on) {
    return Curry._2(Srcs.union, Curry._1(C.srcs, e), Curry._1(C.srcs, on));
  };
  var deps_srcs_changed = function (e, on) {
    if (Curry._1(C.srcs_changed, e)) {
      return true;
    } else {
      return Curry._1(C.srcs_changed, on);
    }
  };
  var update_deps = function (step, e, on) {
    Curry._2(C.update, step, e);
    return Curry._2(C.update, step, on);
  };
  var follow$1 = function (e, on) {
    if (e !== undefined && on) {
      return e;
    }
    
  };
  var update = function (step, self) {
    update_deps(step, e, on);
    if (deps_srcs_changed(e, on)) {
      Curry._2(C.set_srcs, self, deps_srcs(e, on));
    }
    return Curry._3(C.set_instant, step, self, follow$1(Curry._1(C.value, e), Curry._1(C.value, on)));
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, e));
  var step$1 = Curry._2(Src.find_active_step, step, Curry._1(C.srcs, on));
  update_deps(step$1, e, on);
  var init = follow$1(Curry._1(C.value, e), Curry._1(C.value, on));
  return Curry._4(C.create_instant, step$1, deps_srcs(e, on), init, update);
}

function defer$1(e) {
  return Curry._2(C.defer, undefined, e);
}

function fix$1(ef) {
  return Curry._3(C.fix, undefined, undefined, ef);
}

function on_some(e) {
  return filter_map((function (x) {
                return x;
              }), e);
}

function some(e) {
  return map((function (v) {
                return Caml_option.some(v);
              }), e);
}

function value$1(e, $$default) {
  var update = function (step, self) {
    Curry._2(C.update, step, e);
    if (Curry._1(C.srcs_changed, e)) {
      Curry._2(C.set_srcs, self, Curry._1(C.srcs, e));
    }
    var v = Curry._1(C.value, e);
    var occ;
    if (v !== undefined) {
      var v$1 = Caml_option.valFromOption(v);
      if (v$1 !== undefined) {
        occ = v$1;
      } else {
        Curry._2(C.update, step, $$default);
        occ = Caml_option.some(Curry._1(C.value, $$default));
      }
    } else {
      occ = undefined;
    }
    return Curry._3(C.set_instant, step, self, occ);
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, e));
  Curry._2(C.update, step, e);
  Curry._2(C.update, step, $$default);
  var v = Curry._1(C.value, e);
  var init;
  if (v !== undefined) {
    var v$1 = Caml_option.valFromOption(v);
    init = v$1 !== undefined ? v$1 : Caml_option.some(Curry._1(C.value, $$default));
  } else {
    init = undefined;
  }
  return Curry._4(C.create_instant, step, Curry._1(C.srcs, e), init, update);
}

function get(e) {
  return map((function (x) {
                if (x !== undefined) {
                  return Caml_option.valFromOption(x);
                } else {
                  return Pervasives.invalid_arg("option is None");
                }
              }), e);
}

function bind$1(e, f) {
  return map((function (x) {
                if (x !== undefined) {
                  return Curry._1(f, Caml_option.valFromOption(x));
                }
                
              }), e);
}

function join$1(e) {
  return map((function (x) {
                if (x === undefined) {
                  return ;
                }
                var o = Caml_option.valFromOption(x);
                if (o !== undefined) {
                  return o;
                }
                
              }), e);
}

function is_none(e) {
  return map((function (x) {
                return x === undefined;
              }), e);
}

function is_some(e) {
  return map((function (x) {
                return x !== undefined;
              }), e);
}

function map$1(f, e) {
  return map((function (x) {
                if (x !== undefined) {
                  return Caml_option.some(Curry._1(f, Caml_option.valFromOption(x)));
                }
                
              }), e);
}

function fst(e) {
  return map((function (prim) {
                return prim[0];
              }), e);
}

function snd(e) {
  return map((function (prim) {
                return prim[1];
              }), e);
}

function v(e0, e1) {
  var update = function (step, self) {
    Curry._2(C.update, step, e0);
    Curry._2(C.update, step, e1);
    if (Curry._1(C.srcs_changed, e0) || Curry._1(C.srcs_changed, e1)) {
      Curry._2(C.set_srcs, self, Curry._2(Srcs.union, Curry._1(C.srcs, e0), Curry._1(C.srcs, e1)));
    }
    var match = Curry._1(C.value, e0);
    var match$1 = Curry._1(C.value, e1);
    var occ = match !== undefined && match$1 !== undefined ? [
        Caml_option.valFromOption(match),
        Caml_option.valFromOption(match$1)
      ] : undefined;
    return Curry._3(C.set_instant, step, self, occ);
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, e0));
  var step$1 = Curry._2(Src.find_active_step, step, Curry._1(C.srcs, e1));
  var srcs = Curry._2(Srcs.union, Curry._1(C.srcs, e0), Curry._1(C.srcs, e1));
  var match = Curry._1(C.value, e0);
  var match$1 = Curry._1(C.value, e1);
  var init = match !== undefined && match$1 !== undefined ? [
      Caml_option.valFromOption(match),
      Caml_option.valFromOption(match$1)
    ] : undefined;
  return Curry._4(C.create_instant, step$1, srcs, init, update);
}

var Pair = {
  fst: fst,
  snd: snd,
  v: v
};

var eq$1 = C.eq;

function create$5(eq, v) {
  var src = Curry._2(Src.create, eq, v);
  var set = function (step, v) {
    var match = step !== undefined ? [
        Caml_option.valFromOption(step),
        false
      ] : [
        {
          srcs: Srcs.empty,
          delayed: Srcs.empty,
          cleanup: /* [] */0
        },
        true
      ];
    var step$1 = match[0];
    var cell = Curry._1(Src.cell, src);
    if (Curry._3(C.src_update, step$1, cell, v)) {
      add_src(step$1, Curry._1(Src.untyped, src));
    }
    if (match[1]) {
      return execute(step$1);
    }
    
  };
  return [
          Curry._1(Src.cell, src),
          set
        ];
}

var $$const$2 = C.$$const;

function bind$2(v, f) {
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, v));
  Curry._2(C.update, step, v);
  var current = {
    contents: Curry._1(f, Curry._1(C.value, v))
  };
  var update = function (step, self) {
    Curry._2(C.update, step, v);
    if (Curry._1(C.value_changed, v)) {
      current.contents = Curry._1(f, Curry._1(C.value, v));
      Curry._2(C.update, step, current.contents);
      Curry._2(C.set_eq, self, Curry._1(C.eq, current.contents));
      Curry._2(C.set_srcs, self, Curry._2(Srcs.union, Curry._1(C.srcs, v), Curry._1(C.srcs, current.contents)));
      return Curry._2(C.set_value, self, Curry._1(C.value, current.contents));
    } else {
      Curry._2(C.update, step, current.contents);
      if (Curry._1(C.srcs_changed, v) || Curry._1(C.srcs_changed, current.contents)) {
        Curry._2(C.set_srcs, self, Curry._2(Srcs.union, Curry._1(C.srcs, v), Curry._1(C.srcs, current.contents)));
      }
      if (Curry._1(C.value_changed, current.contents)) {
        return Curry._2(C.set_value, self, Curry._1(C.value, current.contents));
      } else {
        return ;
      }
    }
  };
  var step$1 = Curry._2(Src.find_active_step, step, Curry._1(C.srcs, current.contents));
  Curry._2(C.update, step$1, current.contents);
  var srcs = Curry._2(Srcs.union, Curry._1(C.srcs, v), Curry._1(C.srcs, current.contents));
  var init = Curry._1(C.value, current.contents);
  return Curry._5(C.create, Curry._1(C.eq, current.contents), step$1, srcs, init, update);
}

function hold$1(eq, i, e) {
  var update = function (step, self) {
    Curry._2(C.update, step, e);
    if (Curry._1(C.srcs_changed, e)) {
      Curry._2(C.set_srcs, self, Curry._1(C.srcs, e));
    }
    var v = Curry._1(C.value, e);
    if (v !== undefined) {
      return Curry._2(C.set_value, self, Caml_option.valFromOption(v));
    }
    
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, e));
  Curry._2(C.update, step, e);
  var v = Curry._1(C.value, e);
  var init = v !== undefined ? Caml_option.valFromOption(v) : i;
  return Curry._5(C.create, eq, step, Curry._1(C.srcs, e), init, update);
}

function join$2(ss) {
  return bind$2(ss, (function (s) {
                return s;
              }));
}

function swap$1(s, se) {
  var ss = hold$1((function (prim0, prim1) {
          return prim0 === prim1;
        }), s, se);
  return bind$2(ss, (function (s) {
                return s;
              }));
}

function changes(s) {
  var update = function (step, self) {
    Curry._2(C.update, step, s);
    if (Curry._1(C.srcs_changed, s)) {
      Curry._2(C.set_srcs, self, Curry._1(C.srcs, s));
    }
    if (Curry._1(C.value_changed, s)) {
      return Curry._3(C.set_instant, step, self, Caml_option.some(Curry._1(C.value, s)));
    }
    
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, s));
  Curry._2(C.update, step, s);
  return Curry._4(C.create_instant, step, Curry._1(C.srcs, s), undefined, update);
}

function sample(s, on, f) {
  var update = function (step, self) {
    Curry._2(C.update, step, on);
    Curry._2(C.update, step, s);
    if (Curry._1(C.srcs_changed, on) || Curry._1(C.srcs_changed, s)) {
      Curry._2(C.set_srcs, self, Curry._2(Srcs.union, Curry._1(C.srcs, s), Curry._1(C.srcs, on)));
    }
    var v = Curry._1(C.value, on);
    if (v !== undefined) {
      return Curry._3(C.set_instant, step, self, Caml_option.some(Curry._2(f, Curry._1(C.value, s), Caml_option.valFromOption(v))));
    }
    
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, s));
  var step$1 = Curry._2(Src.find_active_step, step, Curry._1(C.srcs, on));
  Curry._2(C.update, step$1, on);
  Curry._2(C.update, step$1, s);
  var srcs = Curry._2(Srcs.union, Curry._1(C.srcs, s), Curry._1(C.srcs, on));
  var v = Curry._1(C.value, on);
  var init = v !== undefined ? Caml_option.some(Curry._2(f, Curry._1(C.value, s), Caml_option.valFromOption(v))) : undefined;
  return Curry._4(C.create_instant, step$1, srcs, init, update);
}

function sample_filter(s, on, f) {
  var e = sample(s, on, f);
  return filter_map((function (x) {
                return x;
              }), e);
}

function snapshot(s, on) {
  return sample(s, on, (function (v, param) {
                return v;
              }));
}

function map$2(eq, f, v) {
  var update = function (step, self) {
    Curry._2(C.update, step, v);
    if (Curry._1(C.srcs_changed, v)) {
      Curry._2(C.set_srcs, self, Curry._1(C.srcs, v));
    }
    if (Curry._1(C.value_changed, v)) {
      return Curry._2(C.set_value, self, Curry._1(f, Curry._1(C.value, v)));
    }
    
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, v));
  Curry._2(C.update, step, v);
  return Curry._5(C.create, eq, step, Curry._1(C.srcs, v), Curry._1(f, Curry._1(C.value, v)), update);
}

function app$1(eq, f, v) {
  var update = function (step, self) {
    Curry._2(C.update, step, f);
    Curry._2(C.update, step, v);
    if (Curry._1(C.srcs_changed, f) || Curry._1(C.srcs_changed, v)) {
      Curry._2(C.set_srcs, self, Curry._2(Srcs.union, Curry._1(C.srcs, f), Curry._1(C.srcs, v)));
    }
    if (Curry._1(C.value_changed, f) || Curry._1(C.value_changed, v)) {
      return Curry._2(C.set_value, self, Curry._2(C.value, f, Curry._1(C.value, v)));
    }
    
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, f));
  var step$1 = Curry._2(Src.find_active_step, step, Curry._1(C.srcs, v));
  Curry._2(C.update, step$1, f);
  Curry._2(C.update, step$1, v);
  var srcs = Curry._2(Srcs.union, Curry._1(C.srcs, f), Curry._1(C.srcs, v));
  var init = Curry._2(C.value, f, Curry._1(C.value, v));
  return Curry._5(C.create, eq, step$1, srcs, init, update);
}

function accum$1(eq, i, e) {
  return hold$1(eq, i, accum(i, e));
}

function until$1(limitOpt, init, next, s) {
  var limit = limitOpt !== undefined ? limitOpt : false;
  var nop = function (step, self) {
    
  };
  var update = function (step, self) {
    Curry._2(C.update, step, next);
    Curry._2(C.update, step, s);
    var match = Curry._1(C.value, next);
    if (match !== undefined) {
      Curry._2(C.set_srcs, self, Srcs.empty);
      Curry._2(C.set_update, self, nop);
      if (limit) {
        return Curry._2(C.set_value, self, Curry._1(C.value, s));
      } else {
        return ;
      }
    } else {
      if (Curry._1(C.srcs_changed, next) || Curry._1(C.srcs_changed, s)) {
        Curry._2(C.set_srcs, self, Curry._2(Srcs.union, Curry._1(C.srcs, next), Curry._1(C.srcs, s)));
      }
      return Curry._2(C.set_value, self, Curry._1(C.value, s));
    }
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, next));
  var step$1 = Curry._2(Src.find_active_step, step, Curry._1(C.srcs, s));
  Curry._2(C.update, step$1, next);
  Curry._2(C.update, step$1, s);
  var match = Curry._1(C.value, next);
  if (match !== undefined) {
    var init$1 = init !== undefined ? Caml_option.valFromOption(init) : Curry._1(C.value, s);
    return Curry._5(C.create, Curry._1(eq$1, s), step$1, Srcs.empty, init$1, nop);
  }
  var srcs = Curry._2(Srcs.union, Curry._1(C.srcs, next), Curry._1(C.srcs, s));
  return Curry._5(C.create, Curry._1(eq$1, s), step$1, srcs, Curry._1(C.value, s), update);
}

function follow$1(init, s, on) {
  var deps_srcs = function (s, on) {
    return Curry._2(Srcs.union, Curry._1(C.srcs, s), Curry._1(C.srcs, on));
  };
  var deps_srcs_changed = function (s, on) {
    if (Curry._1(C.srcs_changed, s)) {
      return true;
    } else {
      return Curry._1(C.srcs_changed, on);
    }
  };
  var update_deps = function (step, s, on) {
    Curry._2(C.update, step, s);
    return Curry._2(C.update, step, on);
  };
  var update = function (step, self) {
    update_deps(step, s, on);
    if (deps_srcs_changed(s, on)) {
      Curry._2(C.set_srcs, self, deps_srcs(s, on));
    }
    if (Curry._1(C.value, on)) {
      return Curry._2(C.set_value, self, Curry._1(C.value, s));
    }
    
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, s));
  var step$1 = Curry._2(Src.find_active_step, step, Curry._1(C.srcs, on));
  update_deps(step$1, s, on);
  var init$1 = init !== undefined ? Caml_option.valFromOption(init) : Curry._1(C.value, s);
  return Curry._5(C.create, Curry._1(eq$1, s), step$1, deps_srcs(s, on), init$1, update);
}

function defer$2(init, s) {
  var init$1;
  if (init !== undefined) {
    init$1 = Caml_option.valFromOption(init);
  } else {
    var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, s));
    Curry._2(C.update, step, s);
    init$1 = Curry._1(C.value, s);
  }
  return Curry._2(C.defer, init$1, s);
}

var l1 = map$2;

function l2(eq, f, x, y) {
  var update = function (step, self) {
    Curry._2(C.update, step, x);
    Curry._2(C.update, step, y);
    if (Curry._1(C.srcs_changed, x) || Curry._1(C.srcs_changed, y)) {
      Curry._2(C.set_srcs, self, Curry._2(Srcs.union, Curry._1(C.srcs, x), Curry._1(C.srcs, y)));
    }
    if (Curry._1(C.value_changed, x) || Curry._1(C.value_changed, y)) {
      return Curry._2(C.set_value, self, Curry._2(f, Curry._1(C.value, x), Curry._1(C.value, y)));
    }
    
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, x));
  var step$1 = Curry._2(Src.find_active_step, step, Curry._1(C.srcs, y));
  Curry._2(C.update, step$1, x);
  Curry._2(C.update, step$1, y);
  var srcs = Curry._2(Srcs.union, Curry._1(C.srcs, x), Curry._1(C.srcs, y));
  var init = Curry._2(f, Curry._1(C.value, x), Curry._1(C.value, y));
  return Curry._5(C.create, eq, step$1, srcs, init, update);
}

function l3(eq, f, x, y, z) {
  var srcs_union = function (x, y, z) {
    return Curry._2(Srcs.union, Curry._1(C.srcs, x), Curry._2(Srcs.union, Curry._1(C.srcs, y), Curry._1(C.srcs, z)));
  };
  var update = function (step, self) {
    Curry._2(C.update, step, x);
    Curry._2(C.update, step, y);
    Curry._2(C.update, step, z);
    if (Curry._1(C.srcs_changed, x) || Curry._1(C.srcs_changed, y) || Curry._1(C.srcs_changed, z)) {
      Curry._2(C.set_srcs, self, srcs_union(x, y, z));
    }
    if (Curry._1(C.value_changed, x) || Curry._1(C.value_changed, y) || Curry._1(C.value_changed, z)) {
      return Curry._2(C.set_value, self, Curry._3(f, Curry._1(C.value, x), Curry._1(C.value, y), Curry._1(C.value, z)));
    }
    
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, x));
  var step$1 = Curry._2(Src.find_active_step, step, Curry._1(C.srcs, y));
  var step$2 = Curry._2(Src.find_active_step, step$1, Curry._1(C.srcs, z));
  Curry._2(C.update, step$2, x);
  Curry._2(C.update, step$2, y);
  Curry._2(C.update, step$2, z);
  var srcs = srcs_union(x, y, z);
  var init = Curry._3(f, Curry._1(C.value, x), Curry._1(C.value, y), Curry._1(C.value, z));
  return Curry._5(C.create, eq, step$2, srcs, init, update);
}

function eq$2(prim0, prim1) {
  return prim0 === prim1;
}

var false$p = Curry._2($$const$2, undefined, false);

var true$p = Curry._2($$const$2, undefined, true);

function not(s) {
  return map$2(eq$2, (function (prim) {
                return !prim;
              }), s);
}

function $amp$amp(param, param$1) {
  return l2(undefined, (function (prim0, prim1) {
                if (prim0) {
                  return prim1;
                } else {
                  return false;
                }
              }), param, param$1);
}

function $pipe$pipe(param, param$1) {
  return l2(undefined, (function (prim0, prim1) {
                if (prim0) {
                  return true;
                } else {
                  return prim1;
                }
              }), param, param$1);
}

var edge = changes;

function edge_detect(edge, s) {
  var update = function (step, self) {
    Curry._2(C.update, step, s);
    if (Curry._1(C.srcs_changed, s)) {
      Curry._2(C.set_srcs, self, Curry._1(C.srcs, s));
    }
    if (Curry._1(C.value_changed, s) && Caml_obj.caml_equal(Curry._1(C.value, s), edge)) {
      return Curry._3(C.set_instant, step, self, Caml_option.some(undefined));
    }
    
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, s));
  Curry._2(C.update, step, s);
  return Curry._4(C.create_instant, step, Curry._1(C.srcs, s), undefined, update);
}

function rise(s) {
  return edge_detect(true, s);
}

function fall(s) {
  return edge_detect(false, s);
}

function flip(init, e) {
  var update = function (step, self) {
    Curry._2(C.update, step, e);
    if (Curry._1(C.srcs_changed, e)) {
      Curry._2(C.set_srcs, self, Curry._1(C.srcs, e));
    }
    var match = Curry._1(C.value, e);
    if (match !== undefined) {
      return Curry._2(C.set_value, self, !Curry._1(C.value, self));
    }
    
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, e));
  Curry._2(C.update, step, e);
  var match = Curry._1(C.value, e);
  var init$1 = match !== undefined ? !init : init;
  return Curry._5(C.create, eq$2, step, Curry._1(C.srcs, e), init$1, update);
}

function _eq(eq, v0, v1) {
  if (v0 !== undefined) {
    if (v1 !== undefined) {
      return Curry._2(eq, Caml_option.valFromOption(v0), Caml_option.valFromOption(v1));
    } else {
      return false;
    }
  } else {
    return v1 === undefined;
  }
}

var none = Curry._2($$const$2, undefined, undefined);

function some$1(s) {
  var partial_arg = Curry._1(eq$1, s);
  return map$2((function (param, param$1) {
                return _eq(partial_arg, param, param$1);
              }), (function (v) {
                return Caml_option.some(v);
              }), s);
}

function hold_value(i, s) {
  var update = function (step, self) {
    Curry._2(C.update, step, s);
    if (Curry._1(C.srcs_changed, s)) {
      Curry._2(C.set_srcs, self, Curry._1(C.srcs, s));
    }
    var v = Curry._1(C.value, s);
    if (v !== undefined) {
      return Curry._2(C.set_value, self, Caml_option.valFromOption(v));
    }
    
  };
  var eq = function (v, v$p) {
    return Curry._3(C.eq, s, Caml_option.some(v), Caml_option.some(v$p));
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, s));
  Curry._2(C.update, step, s);
  var v = Curry._1(C.value, s);
  var init = v !== undefined ? Caml_option.valFromOption(v) : i;
  return Curry._5(C.create, eq, step, Curry._1(C.srcs, s), init, update);
}

function value$2(s, $$default) {
  var update = function (step, self) {
    Curry._2(C.update, step, $$default);
    Curry._2(C.update, step, s);
    if (Curry._1(C.srcs_changed, $$default) || Curry._1(C.srcs_changed, s)) {
      Curry._2(C.set_srcs, self, Curry._2(Srcs.union, Curry._1(C.srcs, $$default), Curry._1(C.srcs, s)));
    }
    if (!(Curry._1(C.value_changed, $$default) || Curry._1(C.value_changed, s))) {
      return ;
    }
    var v = Curry._1(C.value, s);
    if (v !== undefined) {
      return Curry._2(C.set_value, self, Caml_option.valFromOption(v));
    } else {
      return Curry._2(C.set_value, self, Curry._1(C.value, $$default));
    }
  };
  var step = Curry._2(Src.find_active_step, nil, Curry._1(C.srcs, $$default));
  var step$1 = Curry._2(Src.find_active_step, step, Curry._1(C.srcs, s));
  Curry._2(C.update, step$1, $$default);
  Curry._2(C.update, step$1, s);
  var v = Curry._1(C.value, s);
  var init = v !== undefined ? Caml_option.valFromOption(v) : Curry._1(C.value, $$default);
  var srcs = Curry._2(Srcs.union, Curry._1(C.srcs, $$default), Curry._1(C.srcs, s));
  return Curry._5(C.create, Curry._1(eq$1, $$default), step$1, srcs, init, update);
}

function get$1(eq, s) {
  return map$2(eq, (function (x) {
                if (x !== undefined) {
                  return Caml_option.valFromOption(x);
                } else {
                  return Pervasives.invalid_arg("option is None");
                }
              }), s);
}

function bind$3(eq, s, f) {
  return map$2(eq, (function (x) {
                if (x !== undefined) {
                  return Curry._1(f, Caml_option.valFromOption(x));
                }
                
              }), s);
}

function join$3(eq, s) {
  return map$2(eq, (function (x) {
                if (x === undefined) {
                  return ;
                }
                var o = Caml_option.valFromOption(x);
                if (o !== undefined) {
                  return o;
                }
                
              }), s);
}

function is_none$1(s) {
  return map$2(eq$2, (function (x) {
                return x === undefined;
              }), s);
}

function is_some$1(s) {
  return map$2(eq$2, (function (x) {
                return x !== undefined;
              }), s);
}

function map$3(eq, f, s) {
  return map$2(eq, (function (x) {
                if (x !== undefined) {
                  return Caml_option.some(Curry._1(f, Caml_option.valFromOption(x)));
                }
                
              }), s);
}

function fst$1(eq, s) {
  return map$2(eq, (function (prim) {
                return prim[0];
              }), s);
}

function snd$1(eq, s) {
  return map$2(eq, (function (prim) {
                return prim[1];
              }), s);
}

function v$1(s0, s1) {
  return l2(undefined, (function (x, y) {
                return [
                        x,
                        y
                      ];
              }), s0, s1);
}

var Pair$1 = {
  fst: fst$1,
  snd: snd$1,
  v: v$1
};

var Step$1 = {
  create: create,
  execute: execute
};

var Logr_const = Logr.$$const;

var Logr_app = Logr.app;

var Logr_dollar = Logr.dollar;

var Logr_create = Logr.create;

var Logr_force = Logr.force;

var Logr_destroy = Logr.destroy;

var Logr_hold = Logr.hold;

var Logr_may_hold = Logr.may_hold;

var Logr_unhold_all = Logr.unhold_all;

var Logr$1 = {
  $$const: Logr_const,
  app: Logr_app,
  dollar: Logr_dollar,
  create: Logr_create,
  force: Logr_force,
  destroy: Logr_destroy,
  hold: Logr_hold,
  may_hold: Logr_may_hold,
  unhold_all: Logr_unhold_all
};

var E_obs = Logr.obs_cell;

var E_value = C.up_to_date_value;

var E_Option = {
  on_some: on_some,
  some: some,
  value: value$1,
  get: get,
  bind: bind$1,
  join: join$1,
  map: map$1,
  is_none: is_none,
  is_some: is_some
};

var E_dump_src_ids = C.dump_src_ids;

var E = {
  obs: E_obs,
  log: log,
  create: create$4,
  value: E_value,
  never: never,
  bind: bind,
  join: join,
  swap: swap,
  map: map,
  stamp: stamp$1,
  filter: filter,
  filter_map: filter_map,
  select: select,
  accum: accum,
  until: until,
  follow: follow,
  defer: defer$1,
  fix: fix$1,
  $$Option: E_Option,
  Pair: Pair,
  dump_src_ids: E_dump_src_ids
};

var S_obs = Logr.obs_cell;

var S_log = Logr.for_cell;

var S_with_eq = C.with_eq;

var S_value = C.up_to_date_value;

var S_rough_value = C.value;

var S_delay = C.delay;

var S_fix = C.fix;

var S_Bool = {
  false$p: false$p,
  true$p: true$p,
  not: not,
  $amp$amp: $amp$amp,
  $pipe$pipe: $pipe$pipe,
  edge: edge,
  rise: rise,
  fall: fall,
  flip: flip
};

var S_Option = {
  eq: _eq,
  hold_value: hold_value,
  none: none,
  some: some$1,
  value: value$2,
  get: get$1,
  bind: bind$3,
  join: join$3,
  map: map$3,
  is_none: is_none$1,
  is_some: is_some$1
};

var S_dump_src_ids = C.dump_src_ids;

var S = {
  obs: S_obs,
  log: S_log,
  create: create$5,
  eq: eq$1,
  with_eq: S_with_eq,
  value: S_value,
  rough_value: S_rough_value,
  $$const: $$const$2,
  hold: hold$1,
  bind: bind$2,
  join: join$2,
  swap: swap$1,
  changes: changes,
  map: map$2,
  app: app$1,
  sample: sample,
  sample_filter: sample_filter,
  snapshot: snapshot,
  accum: accum$1,
  until: until$1,
  follow: follow$1,
  defer: defer$2,
  delay: S_delay,
  fix: S_fix,
  l1: l1,
  l2: l2,
  l3: l3,
  Bool: S_Bool,
  $$Option: S_Option,
  Pair: Pair$1,
  dump_src_ids: S_dump_src_ids
};

exports.Step = Step$1;
exports.Logr = Logr$1;
exports.E = E;
exports.S = S;
/* Src Not a pure module */
